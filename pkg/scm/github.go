package scm

import (
	"context"
	gogithub "github.com/google/go-github/v53/github"
	pkgctx "gomod.alauda.cn/gomod-version-lint/pkg/context"
	"strings"
)

type githubClient struct {
	*gogithub.Client
}

func NewGithubClient(ctx context.Context, token string) *githubClient {
	return &githubClient{
		Client: gogithub.NewTokenClient(ctx, token),
	}
}

func (github *githubClient) RefreshReviewComments(ctx context.Context, repoPath string, prId int, opts RefreshReviewCommentOptions) error {
	logger := pkgctx.GetLogger(ctx).With("prID", prId)

	owner, repo := getOwner(repoPath)

	allComments, _, err := github.PullRequests.ListComments(ctx, owner, repo, prId, &gogithub.PullRequestListCommentsOptions{
		ListOptions: gogithub.ListOptions{
			PerPage: 200,
			Page:    1,
		},
	})
	if err != nil {
		return err
	}

	// add comment again
	for _, item := range opts.Comments {
		logger.Debugf("creating comment")
		body := item.FmtComment(opts.CommentBy)
		comment, _, err := github.PullRequests.CreateComment(ctx, owner, repo, prId, &gogithub.PullRequestComment{
			Body:     &body,
			CommitID: &opts.CommitID,
			Path:     &item.Path,
			Line:     &item.Line,
		})
		if err != nil {
			logger.Errorw("create comment error", "body", item.Body, "id", comment.ID, "err", err.Error())
		} else {
			logger.Infow("created comment", "body", item.Body, "id", comment.ID)
		}
	}

	// Delete all comment generated by current
	commentsShouldBeDeleted := []gogithub.PullRequestComment{}
	for _, item := range allComments {
		_item := *item
		if strings.HasPrefix(*item.Body, opts.FmtCommentBy()) {
			commentsShouldBeDeleted = append(commentsShouldBeDeleted, _item)
		}
	}
	for _, item := range commentsShouldBeDeleted {
		logger.Debugw("deleting old comment", "id", item.ID)
		_, err = github.PullRequests.DeleteComment(ctx, owner, repo, *item.ID)
		if err != nil {
			logger.Errorw("deleted old comment error", "err", err)
		} else {
			logger.Infow("deleted old comment", "id", item.ID)
		}
	}

	return nil
}

func getOwner(repoPath string) (owner string, repo string) {
	segments := strings.Split(repoPath, "/")
	return segments[0], strings.TrimPrefix(repoPath, segments[0]+"/")
}
